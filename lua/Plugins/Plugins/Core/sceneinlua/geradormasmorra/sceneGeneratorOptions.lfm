<?xml version="1.0" encoding="UTF-8"?>
<popupForm name="frmGeneratorOptions" width="300" height="300" drawContainer="true" resizable="true" placement="center"
		   cancelable="false">
 		   
	<import file="../interfaceUtils.xml"/>
	<style>
		flowPart.optionPart {
			height: 30;
			minWidth: 50;
			maxWidth: 5000;
			margins: {left=2, right=2, top=2, bottom=2};
		}
		
		.itemTitle {
			align: left;
			width: 110;
			autoSize: false;
			horzTextAlign: trailing;	
			vertTextAlign: center;
			margins:{right=5};
		}
		
		.itemContent {
			align: client;
			margins:{right=5};
		}
		
		.groupTitle {
			align: left;						
			autoSize: true;
			wordWrap: false;
			horzTextAlign: leading;	
			vertTextAlign: center;
			margins:{left=10, right=5};		
			fontSize: 15;
			fontColor: #FFCC66;
		}
		
	</style>
			
	<script>
		require("system.lua");
		require("rrpgScene_Undo.dlua");
		local scene = nil;	
		
		if not System.isMobile() then
			self.height = 450;
		end;
	</script>	
	
	<template name="option">
		<label name="$(field)Text" left="10" top="$(top)" width="120" height="25" text="$(text)" hitTest="true" hint="$(hint)" horzTextAlign="trailing"/>
		<edit left="140" top="$(top)" width="50" height="25" name="$(field)" type="number"/>
	</template>
	<template name="tileEdit">
		<image left="$(left)" top="0" width="64" height="64"  style="stretch" name="$(field)Img" editable="true"/>
		<label left="$(left)" top="64" width="64" height="15" fontSize="8"/>
	</template>

	<tabControl align="client">
		<tab name="tabOptions">
			<scrollBox align="client">
				<label text="" name="tabName" align="top" margins="{left=10, right=5}" fontSize="15" fontColor="#FFCC66"/>
				<horzLine align="top" strokeColor="#FFCC6670" margins="{left=10}"/>	

				<option top="30" text="" field="salas" hint="Quantidade Maxima de Salas."/>
				<option top="55" text="" field="tamMax" hint="Tamanho maximo da sala (min. 4)"/>
				<option top="80" text="" field="tamMin" hint="Tamanho minimo da sala (min. 3)"/>
				<option top="105" text="" field="entradas" hint="Quantidade de entradas"/>
				<option top="130" text="" field="escadas" hint="Quantidade de escadas"/>
				<option top="155" text="" field="becos" hint="Quantidade de becos"/>
				<option top="180" text="" field="armadilhas" hint=""/>
				<option top="205" text="" field="passagens" hint=""/>

				<label left="5" top="230" width="130" name="thickness" horzTextAlign="trailing" hitTest="true"/>
				<comboBox left="140" top="230" width="50" name="thick" items="{'1','1.5','2', '3'}"/>

				<checkBox left="120" top="255" width="130" name="natural" hitTest="true"/>
			</scrollBox>
		</tab>
		<tab name="tabTiles">
			<scrollBox align="client">
				<label left="5" top="5" name="style" margins="{left=10, right=5}" fontSize="15" fontColor="#FFCC66"/>
				<comboBox left="75" top="5" width="175" name="styleOptions">
					<event name="onChange">
						if self.styleOptions.value == lang('scene.generator.tiles.style1') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/LLBKLNNN_328371.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/NSVRSNLG_328370.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/EDUPFJLI_328660.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/AEHGOPMH_332114.png";

							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/DCCHNTNH_328338.png";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/VBQRSILF_328334.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/CHKWJATW_328360.png";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/RKDFSJOR_328336.png";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/OUICQAEA_328330.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/MFRICDNQ_328364.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/FALFKGFW_328365.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/SUJINTTV_328324.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/EQDFPEFJ_328323.png";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/MKBOEQSN_328560.png";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/RKJUVLDJ_328561.png";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/KEUMVLIT_328361.png";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/DIGAMPSO_328538.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/KKVCTGSV_328328.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/VGRUNOJU_328508.png";

							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/ERKWBFJS_328345.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/LBOAERRP_328342.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/IRSBUCLP_328346.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/SDMDKCTL_328344.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/HKWNFCIW_328340.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/CVFPGFHI_328350.png";
						elseif self.styleOptions.value == lang('scene.generator.tiles.style2') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/AWJKDKAC_328734.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/KEILLRML_328736.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/HPNFUWKV_332117.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/CBHDTEGQ_332116.png";
							
							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/KRRTQJUG_328743.png";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/FFFCNNRA_328748.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/TGSUMGBG_328740.png";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/RCASWDBH_328764.png";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/TGERSJBG_328750.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/JSDMTBKW_328746.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/CPLNFUGG_328756.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/IJOQKWAB_328778.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/PPIQFHNO_328735.png";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/TMGOVKAH_328776.png";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/OCLLPSKP_328759.png";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/KJEAMHJU_328742.png";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/RDPGAKCT_328753.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/CAMUVFGO_328752.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/RHNLHKTP_328772.png";

							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/KJGCUDAM_328762.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/FWMBVBCB_328758.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/WBUQKCPR_328770.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/WVUEGBNU_328765.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/HCGLWRRC_328768.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/QLOPOGTG_328774.png";
						elseif self.styleOptions.value == lang('scene.generator.tiles.style3') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/ASGFSISW_329320.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/ASGFSISW_329320.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/CJJFVOHM_332120.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/ASGFSISW_329320.png";
							
							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/WLWRMANJ_329322.jpg";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/CBDUBAMQ_329345.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/TTNASKFU_329323.jpg";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/DQCKIBNU_329328.jpg";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/MTEOMLWF_329338.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/BMDMFEMN_329337.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/OEGFLVQO_329343.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/ITRDMMWK_329347.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/BTWIOSUO_329326.jpg";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/FTFIPHHK_329352.jpg";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/PDOLMBKA_329335.jpg";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/PPGPCUGT_329358.jpg";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/GLSWWJBD_329332.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/SHGBFFHA_329341.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/GHANDAIU_329331.png";

							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/EHBQVTHS_329351.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/EHBQVTHS_329351.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/EHBQVTHS_329351.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/EHBQVTHS_329351.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/EHBQVTHS_329351.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/EHBQVTHS_329351.png";
						elseif self.styleOptions.value == lang('scene.generator.tiles.style4') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/IHNOSLRB_329541.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/QLSSSSQM_329580.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/UVWDHKET_332122.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/HQASAGPB_332124.png";

							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/KNKLUVFJ_329540.png";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/OEWGPTTL_329576.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/IWLQGFRB_329534.png";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/BFHBERSL_329570.png";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/MCJPCEDL_329536.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/LONCNMBR_329546.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/DMQPIQJR_329544.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/BDLQMCWU_329560.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/JFIIPDRF_329554.png";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/OAAFLUJI_329558.png";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/EUMIELCK_329566.png";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/LTDWDTPC_329535.png";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/UTWCKBMF_329568.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/HVARPVMD_329578.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/NFGUROCR_329572.png";

							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/FRJIBOIQ_329562.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/SSUOWVOT_329550.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/OVJWNISR_329551.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/KHSKBVNB_329556.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/PSHQKLON_329574.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/GPCUFOBC_329563.png";
						elseif self.styleOptions.value == lang('scene.generator.tiles.style5') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/LJKGSFOM_329829.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/OUOWGIWF_329825.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/LTUAEHIS_332128.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/CUJPIRNK_332126.png";
							
							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/LSBVEFUE_329833.png";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/HCTNMNTG_329849.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/QFCUPDKL_329827.png";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/GWLTJWQD_329851.png";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/VJRLJLIP_329835.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/JETNCEDV_329837.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/AGQVIIOC_329831.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/BGNSEQEV_329853.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/MUGCAHCC_329843.png";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/MHTBQHCU_329841.png";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/DQKUIGSA_329855.png";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/MJWUJEGV_329865.png";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/VFLPUBSF_329839.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/VNAMTMGA_329847.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/TJSMPUQJ_331903.png";
							
							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/VNQTBSEP_329857.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/ANHEQLQS_329863.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/JCEANFAN_329869.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/OCIAJCEG_329861.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/SBKLABQH_329859.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/EBQHSNUU_329867.png";
						elseif self.styleOptions.value == lang('scene.generator.tiles.style6') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/RIUGQSGD_330392.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/LROGHUWU_330376.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/GAAAHVRC_332132.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/RIUGQSGD_330392.png";
							
							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/CBRDIDTG_330380.png";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/TKUGJHBB_330394.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/DWVVDDLE_330381.png";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/JTGVLEUL_330402.png";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/ENDICILC_330390.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/CUINVIGD_330372.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/EFEVEHJF_330374.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/BVVUVHGR_330396.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/WVBEANSO_330378.png";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/GRONQQCD_330400.png";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/EWLELELT_330386.png";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/GKMWAGIV_330384.png";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/UPEJUFOG_330404.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/MHGHUWBT_330388.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/JVRJFNEO_330398.png";
							
							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/HKTNHTLV_330408.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/FQKBVDRE_330414.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/WFGNBKEK_330406.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/DGRLUWEC_330416.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/WULMLDKW_330412.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/OGNMMJLI_330410.png";
						elseif self.styleOptions.value == lang('scene.generator.tiles.style7') and node.save1~=nil then
							self.door_light.url = node.save1[1];
							self.door_heavy.url = node.save1[2];
							self.floor_deadend.url = node.save1[3];
							self.floor_line.url = node.save1[4];
							self.floor_curve.url = node.save1[5];
							self.floor_tip.url = node.save1[6];
							self.floor_t.url = node.save1[7];
							self.floor_coneright.url = node.save1[8];
							self.floor_coneleft.url = node.save1[9];
							self.floor_side.url = node.save1[10];
							self.floor_cross.url = node.save1[11];
							self.floor_twoway.url = node.save1[12];
							self.floor_opositeway.url = node.save1[13];
							self.floor_exit.url = node.save1[14];
							self.floor_opencurve.url = node.save1[15];
							self.floor_inside.url = node.save1[16];
							self.floor_stair.url = node.save1[17];
							self.wall_cross.url = node.save1[18];
							self.wall_t.url = node.save1[19];
							self.wall_line.url = node.save1[20];
							self.wall_curve.url = node.save1[21];
							self.wall_deadend.url = node.save1[22];
							self.wall_pilar.url = node.save1[23];
							self.trap.url = node.save1[24];
							self.passage.url = node.save1[25];
						elseif self.styleOptions.value == lang('scene.generator.tiles.style8') and node.save2~=nil then
							self.door_light.url = node.save2[1];
							self.door_heavy.url = node.save2[2];
							self.floor_deadend.url = node.save2[3];
							self.floor_line.url = node.save2[4];
							self.floor_curve.url = node.save2[5];
							self.floor_tip.url = node.save2[6];
							self.floor_t.url = node.save2[7];
							self.floor_coneright.url = node.save2[8];
							self.floor_coneleft.url = node.save2[9];
							self.floor_side.url = node.save2[10];
							self.floor_cross.url = node.save2[11];
							self.floor_twoway.url = node.save2[12];
							self.floor_opositeway.url = node.save2[13];
							self.floor_exit.url = node.save2[14];
							self.floor_opencurve.url = node.save2[15];
							self.floor_inside.url = node.save2[16];
							self.floor_stair.url = node.save2[17];
							self.wall_cross.url = node.save2[18];
							self.wall_t.url = node.save2[19];
							self.wall_line.url = node.save2[20];
							self.wall_curve.url = node.save2[21];
							self.wall_deadend.url = node.save2[22];
							self.wall_pilar.url = node.save2[23];
							self.trap.url = node.save2[24];
							self.passage.url = node.save2[25];
						elseif self.styleOptions.value == lang('scene.generator.tiles.style9') and node.save3~=nil then
							self.door_light.url = node.save3[1];
							self.door_heavy.url = node.save3[2];
							self.floor_deadend.url = node.save3[3];
							self.floor_line.url = node.save3[4];
							self.floor_curve.url = node.save3[5];
							self.floor_tip.url = node.save3[6];
							self.floor_t.url = node.save3[7];
							self.floor_coneright.url = node.save3[8];
							self.floor_coneleft.url = node.save3[9];
							self.floor_side.url = node.save3[10];
							self.floor_cross.url = node.save3[11];
							self.floor_twoway.url = node.save3[12];
							self.floor_opositeway.url = node.save3[13];
							self.floor_exit.url = node.save3[14];
							self.floor_opencurve.url = node.save3[15];
							self.floor_inside.url = node.save3[16];
							self.floor_stair.url = node.save3[17];
							self.wall_cross.url = node.save3[18];
							self.wall_t.url = node.save3[19];
							self.wall_line.url = node.save3[20];
							self.wall_curve.url = node.save3[21];
							self.wall_deadend.url = node.save3[22];
							self.wall_pilar.url = node.save3[23];
							self.trap.url = node.save3[24];
							self.passage.url = node.save3[25];
						elseif self.styleOptions.value == lang('scene.generator.tiles.style10') then
							self.door_light.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.door_heavy.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.trap.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.passage.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_deadend.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_line.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_curve.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_tip.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_t.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_coneright.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_coneleft.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_side.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_cross.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_twoway.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_opositeway.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_exit.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_opencurve.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_inside.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.floor_stair.url = "http://firecast.blob.core.windows.net/blobs/RLCOISRC_331335.png";
							self.wall_cross.url = "http://firecast.blob.core.windows.net/blobs/BOINHCPW_344827.png";
							self.wall_t.url = "http://firecast.blob.core.windows.net/blobs/JAFEEKVG_344832.png";
							self.wall_line.url = "http://firecast.blob.core.windows.net/blobs/BUVMSHJO_344838.png";
							self.wall_curve.url = "http://firecast.blob.core.windows.net/blobs/QDUISQSL_344829.png";
							self.wall_deadend.url = "http://firecast.blob.core.windows.net/blobs/ESOQKQNL_344834.png";
							self.wall_pilar.url = "http://firecast.blob.core.windows.net/blobs/MBSBDVKQ_344836.png";
						end;
					</event>
                </comboBox>

                <label left="5" top="30" name="saves" margins="{left=10, right=5}" fontSize="15" fontColor="#FFCC66" hitTest="true" />
				<comboBox left="75" top="30" width="175" name="saveTile" items="{'1', '2', '3'}">
					<event name="onChange">
						if self.saveTile.value == "1" then
							node.save1 = {};
							node.save1[1] = self.door_light.url;
							node.save1[2] = self.door_heavy.url;
							node.save1[3] = self.floor_deadend.url;
							node.save1[4] = self.floor_line.url;
							node.save1[5] = self.floor_curve.url;
							node.save1[6] = self.floor_tip.url;
							node.save1[7] = self.floor_t.url;
							node.save1[8] = self.floor_coneright.url;
							node.save1[9] = self.floor_coneleft.url;
							node.save1[10] = self.floor_side.url;
							node.save1[11] = self.floor_cross.url;
							node.save1[12] = self.floor_twoway.url;
							node.save1[13] = self.floor_opositeway.url;
							node.save1[14] = self.floor_exit.url;
							node.save1[15] = self.floor_opencurve.url;
							node.save1[16] = self.floor_inside.url;
							node.save1[17] = self.floor_stair.url;
							node.save1[18] = self.wall_cross.url;
							node.save1[19] = self.wall_t.url;
							node.save1[20] = self.wall_line.url;
							node.save1[21] = self.wall_curve.url;
							node.save1[22] = self.wall_deadend.url;
							node.save1[23] = self.wall_pilar.url;
							node.save1[24] = self.trap.url;
							node.save1[25] = self.passage.url;
						elseif self.saveTile.value == "2" then
							node.save2 = {};
							node.save2[1] = self.door_light.url;
							node.save2[2] = self.door_heavy.url;
							node.save2[3] = self.floor_deadend.url;
							node.save2[4] = self.floor_line.url;
							node.save2[5] = self.floor_curve.url;
							node.save2[6] = self.floor_tip.url;
							node.save2[7] = self.floor_t.url;
							node.save2[8] = self.floor_coneright.url;
							node.save2[9] = self.floor_coneleft.url;
							node.save2[10] = self.floor_side.url;
							node.save2[11] = self.floor_cross.url;
							node.save2[12] = self.floor_twoway.url;
							node.save2[13] = self.floor_opositeway.url;
							node.save2[14] = self.floor_exit.url;
							node.save2[15] = self.floor_opencurve.url;
							node.save2[16] = self.floor_inside.url;
							node.save2[17] = self.floor_stair.url;
							node.save2[18] = self.wall_cross.url;
							node.save2[19] = self.wall_t.url;
							node.save2[20] = self.wall_line.url;
							node.save2[21] = self.wall_curve.url;
							node.save2[22] = self.wall_deadend.url;
							node.save2[23] = self.wall_pilar.url;
							node.save2[24] = self.trap.url;
							node.save2[25] = self.passage.url;
						elseif self.saveTile.value == "3" then
							node.save3 = {};
							node.save3[1] = self.door_light.url;
							node.save3[2] = self.door_heavy.url;
							node.save3[3] = self.floor_deadend.url;
							node.save3[4] = self.floor_line.url;
							node.save3[5] = self.floor_curve.url;
							node.save3[6] = self.floor_tip.url;
							node.save3[7] = self.floor_t.url;
							node.save3[8] = self.floor_coneright.url;
							node.save3[9] = self.floor_coneleft.url;
							node.save3[10] = self.floor_side.url;
							node.save3[11] = self.floor_cross.url;
							node.save3[12] = self.floor_twoway.url;
							node.save3[13] = self.floor_opositeway.url;
							node.save3[14] = self.floor_exit.url;
							node.save3[15] = self.floor_opencurve.url;
							node.save3[16] = self.floor_inside.url;
							node.save3[17] = self.floor_stair.url;
							node.save3[18] = self.wall_cross.url;
							node.save3[19] = self.wall_t.url;
							node.save3[20] = self.wall_line.url;
							node.save3[21] = self.wall_curve.url;
							node.save3[22] = self.wall_deadend.url;
							node.save3[23] = self.wall_pilar.url;
							node.save3[24] = self.trap.url;
							node.save3[25] = self.passage.url;
						end;						
					</event>
				</comboBox>

				<layout left="0" top="55" height="630" width="300">
					<label text="" name="tiles1" align="top" fontSize="15" fontColor="#FFCC66"/>
					<horzLine align="top" strokeColor="#FFCC6670" margins="{left=10}"/>

					<image left="5" top="30" width="64" height="64"  style="stretch" name="door_light" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.door_light.url);
					    </event>
					</image>
					<image left="74" top="30" width="64" height="64"  style="stretch" name="door_heavy" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.door_heavy.url);
					    </event>
					</image>
					<image left="143" top="30" width="64" height="64"  style="stretch" name="trap" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.trap.url);
					    </event>
					</image>
					<image left="212" top="30" width="64" height="64"  style="stretch" name="passage" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.passage.url);
					    </event>
					</image>

					<label text="" name="tiles2" top="110" width="250" fontSize="15" fontColor="#FFCC66"/>
					<horzLine top="130" width="250" strokeColor="#FFCC6670" margins="{left=10}"/>
					
					<image left="5" top="140" width="64" height="64"  style="stretch" name="floor_deadend" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_deadend.url);
					    </event>
					</image>
					<image left="74" top="140" width="64" height="64"  style="stretch" name="floor_line" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_line.url);
					    </event>
					</image>
					<image left="143" top="140" width="64" height="64"  style="stretch" name="floor_curve" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_curve.url);
					    </event>
					</image>
					<image left="212" top="140" width="64" height="64"  style="stretch" name="floor_tip" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_tip.url);
					    </event>
					</image>
					
					<image left="5" top="209" width="64" height="64"  style="stretch" name="floor_t" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_t.url);
					    </event>
					</image>
					<image left="74" top="209" width="64" height="64"  style="stretch" name="floor_coneright" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_coneright.url);
					    </event>
					</image>
					<image left="143" top="209" width="64" height="64"  style="stretch" name="floor_coneleft" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_coneleft.url);
					    </event>
					</image>
					<image left="212" top="209" width="64" height="64"  style="stretch" name="floor_side" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_side.url);
					    </event>
					</image>

					<image left="5" top="278" width="64" height="64"  style="stretch" name="floor_cross" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_cross.url);
					    </event>
					</image>
					<image left="74" top="278" width="64" height="64"  style="stretch" name="floor_twoway" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_twoway.url);
					    </event>
					</image>
					<image left="143" top="278" width="64" height="64"  style="stretch" name="floor_opositeway" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_opositeway.url);
					    </event>
					</image>
					<image left="212" top="278" width="64" height="64"  style="stretch" name="floor_exit" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_exit.url);
					    </event>
					</image>

					<image left="5" top="347" width="64" height="64"  style="stretch" name="floor_opencurve" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_opencurve.url);
					    </event>
					</image>
					<image left="74" top="347" width="64" height="64"  style="stretch" name="floor_inside" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_inside.url);
					    </event>
					</image>
					<image left="143" top="347" width="64" height="64"  style="stretch" name="floor_stair" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.floor_stair.url);
					    </event>
					</image>

					<label text="" name="tiles3" top="447" width="250" fontSize="15" fontColor="#FFCC66"/>
					<horzLine top="467" width="250" strokeColor="#FFCC6670" margins="{left=10}"/>

					<image left="5" top="487" width="64" height="64"  style="stretch" name="wall_cross" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.wall_cross.url);
					    </event>
					</image>
					<image left="74" top="487" width="64" height="64"  style="stretch" name="wall_t" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.wall_t.url);
					    </event>
					</image>
					<image left="143" top="487" width="64" height="64"  style="stretch" name="wall_line" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.wall_line.url);
					    </event>
					</image>
					<image left="212" top="487" width="64" height="64"  style="stretch" name="wall_curve" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.wall_curve.url);
					    </event>
					</image>

					<image left="5" top="556" width="64" height="64"  style="stretch" name="wall_deadend" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.wall_deadend.url);
					    </event>
					</image>
					<image left="74" top="556" width="64" height="64"  style="stretch" name="wall_pilar" editable="true">
						<event name="OnStartDrag">
					        drag:addData("imageURL", self.wall_pilar.url);
					    </event>
					</image>

				</layout>

			</scrollBox>
		</tab>
	</tabControl>

	
	<BottomActionCancelPopupPanel actionClick="self:processarOK()" cancelClick="self:processarCancel()"/>
	
	<script><![CDATA[
		local node = NDB.load("generatorOptions.xml");
		self.tabOptions.text = lang('scene.generator.tab.options');
		self.tabTiles.text = lang('scene.generator.tab.tiles');
		self.tabName.text = lang('scene.generator.tabName');
		self.salasText.text = lang('scene.generator.salas.text');
		self.salasText.hint = lang('scene.generator.salas.hint');
		self.tamMaxText.text = lang('scene.generator.tamMax.text');
		self.tamMaxText.hint = lang('scene.generator.tamMax.hint');
		self.tamMinText.text = lang('scene.generator.tamMin.text');
		self.tamMinText.hint = lang('scene.generator.tamMin.hint');
		self.entradasText.text = lang('scene.generator.entradas.text');
		self.entradasText.hint = lang('scene.generator.entradas.hint');
		self.escadasText.text = lang('scene.generator.escadas.text');
		self.escadasText.hint = lang('scene.generator.escadas.hint');
		self.armadilhasText.text = lang('scene.generator.armadilhas.text');
		self.armadilhasText.hint = lang('scene.generator.armadilhas.hint');
		self.passagensText.text = lang('scene.generator.passagens.text');
		self.passagensText.hint = lang('scene.generator.passagens.hint');
		self.becosText.text = lang('scene.generator.becos.text');
		self.becosText.hint = lang('scene.generator.becos.hint');
		self.saves.text = lang('scene.generator.saves.text');
		self.saves.hint = lang('scene.generator.saves.hint');
		self.natural.text = lang('scene.generator.natural.text');
		self.natural.hint = lang('scene.generator.natural.hint');

		if node.salas == nil then
			node.salas = 20;
			node.tamMax = 5;
			node.tamMin = 3;
			node.entradas = 1;
			node.escadas = 2;
			node.becos = 0;
			node.armadilhas = 2;
			node.passagens = 2;
			node.natural = false;
			node.thick = "2";
			node.style = lang('scene.generator.tiles.style1');
			node.save = {};
			node.save[1] = "http://firecast.blob.core.windows.net/blobs/LLBKLNNN_328371.png";
			node.save[2] = "http://firecast.blob.core.windows.net/blobs/NSVRSNLG_328370.png";
			node.save[3] = "http://firecast.blob.core.windows.net/blobs/DCCHNTNH_328338.png";
			node.save[4] = "http://firecast.blob.core.windows.net/blobs/VBQRSILF_328334.png";
			node.save[5] = "http://firecast.blob.core.windows.net/blobs/CHKWJATW_328360.png";
			node.save[6] = "http://firecast.blob.core.windows.net/blobs/RKDFSJOR_328336.png";
			node.save[7] = "http://firecast.blob.core.windows.net/blobs/OUICQAEA_328330.png";
			node.save[8] = "http://firecast.blob.core.windows.net/blobs/MFRICDNQ_328364.png";
			node.save[9] = "http://firecast.blob.core.windows.net/blobs/FALFKGFW_328365.png";
			node.save[10] = "http://firecast.blob.core.windows.net/blobs/SUJINTTV_328324.png";
			node.save[11] = "http://firecast.blob.core.windows.net/blobs/EQDFPEFJ_328323.png";
			node.save[12] = "http://firecast.blob.core.windows.net/blobs/MKBOEQSN_328560.png";
			node.save[13] = "http://firecast.blob.core.windows.net/blobs/RKJUVLDJ_328561.png";
			node.save[14] = "http://firecast.blob.core.windows.net/blobs/KEUMVLIT_328361.png";
			node.save[15] = "http://firecast.blob.core.windows.net/blobs/DIGAMPSO_328538.png";
			node.save[16] = "http://firecast.blob.core.windows.net/blobs/KKVCTGSV_328328.png";
			node.save[17] = "http://firecast.blob.core.windows.net/blobs/VGRUNOJU_328508.png";
			node.save[18] = "http://firecast.blob.core.windows.net/blobs/ERKWBFJS_328345.png";
			node.save[19] = "http://firecast.blob.core.windows.net/blobs/LBOAERRP_328342.png";
			node.save[20] = "http://firecast.blob.core.windows.net/blobs/IRSBUCLP_328346.png";
			node.save[21] = "http://firecast.blob.core.windows.net/blobs/SDMDKCTL_328344.png";
			node.save[22] = "http://firecast.blob.core.windows.net/blobs/HKWNFCIW_328340.png";
			node.save[23] = "http://firecast.blob.core.windows.net/blobs/CVFPGFHI_328350.png";
			node.save[24] = "http://firecast.blob.core.windows.net/blobs/EDUPFJLI_328660.png";
			node.save[25] = "http://firecast.blob.core.windows.net/blobs/AEHGOPMH_332114.png";
		end;

		self.salas.text = node.salas;
		self.tamMax.text = node.tamMax;
		self.tamMin.text = node.tamMin;
		self.entradas.text = node.entradas;
		self.escadas.text = node.escadas;
		self.becos.text = node.becos;
		self.armadilhas.text = node.armadilhas;
		self.passagens.text = node.passagens;
		self.natural.checked = node.natural;

		self.thickness.text = lang('scene.generator.thickness.text');
		self.thickness.hint = lang('scene.generator.thickness.hint');
		self.thick.value = node.thick;

		self.style.text = lang('scene.generator.tiles.style');
		
		self.styleOptions.items = {lang("scene.generator.tiles.style1"), 
								  lang("scene.generator.tiles.style2"), 
								  lang("scene.generator.tiles.style3"), 
								  lang("scene.generator.tiles.style4"), 
								  lang("scene.generator.tiles.style5"), 
								  lang("scene.generator.tiles.style6"), 
								  lang("scene.generator.tiles.style10"), 
								  lang("scene.generator.tiles.style7"), 
								  lang("scene.generator.tiles.style8"), 
								  lang("scene.generator.tiles.style9")};

		self.tiles1.text = lang('scene.generator.tiles.door');
		self.tiles2.text = lang('scene.generator.tiles.floor');
		self.tiles3.text = lang('scene.generator.tiles.wall');
		self.door_light.url = node.save[1];
		self.door_heavy.url = node.save[2];
		self.floor_deadend.url = node.save[3];
		self.floor_line.url = node.save[4];
		self.floor_curve.url = node.save[5];
		self.floor_tip.url = node.save[6];
		self.floor_t.url = node.save[7];
		self.floor_coneright.url = node.save[8];
		self.floor_coneleft.url = node.save[9];
		self.floor_side.url = node.save[10];
		self.floor_cross.url = node.save[11];
		self.floor_twoway.url = node.save[12];
		self.floor_opositeway.url = node.save[13];
		self.floor_exit.url = node.save[14];
		self.floor_opencurve.url = node.save[15];
		self.floor_inside.url = node.save[16];
		self.floor_stair.url = node.save[17];
		self.wall_cross.url = node.save[18];
		self.wall_t.url = node.save[19];
		self.wall_line.url = node.save[20];
		self.wall_curve.url = node.save[21];
		self.wall_deadend.url = node.save[22];
		self.wall_pilar.url = node.save[23];
		self.trap.url = node.save[24];
		self.passage.url = node.save[25];
		self.styleOptions.value = node.style;

		--self.status.text = lang('scene.generator.status.message') .. lang('scene.generator.status.wait');

		function self:prepareForShow(oScene)
			scene = oScene;
		end;

		function self:processarOK()	
			scene.bkgColor = "black";	
			scene.grid.gridColor = "gray";

			-- Limpando scene atual
			scene.isViewingAsGM = true;
			scene.fogOfWar:resetOpaqueAreas();
			local deletions = #scene.items;
			for i=deletions, 1, -1 do
				if scene.items[i]~=nil and scene.items[i].layer=="background" then
					scene.items[i]:delete();
				end;
			end;
			scene.fogOfWar.enabled = true;

			-- Inicializando variaveis uteis
			local thick = tonumber(self.thick.value) or 1;
			local size = scene.grid.cellSize * thick;
			local horzSquare = math.floor(scene.worldWidth/size);
			local vertSquare = math.floor(scene.worldHeight/size);

			local centros = {};
			local centrosNum = 1;
			local map = {};
			for i=1, horzSquare, 1 do
				map[i] = {};
				for j=1, vertSquare, 1 do
					map[i][j] = "nada";
					-- Marcar bordas do mapa
					if i==1 or j==1 or i==horzSquare or j==vertSquare then
						map[i][j] = "borda";
					end;
				end;
			end;

			-- Pegando opções do usuario
			local salas = self.salas.asNumber or 1;
			local limit = (self.salas.asNumber or 1)*2;
			local tamMax = self.tamMax.asNumber or 4;
			if tamMax < 4 then
				tamMax = 4;
			end;
			local tamMin = self.tamMin.asNumber or 3;
			if tamMin < 3 then
				tamMin = 3;
			end;
			if tamMin > tamMax then
				tamMin = 3;
				tamMax = 4;
			end;

			local entradas = self.entradas.asNumber or 0;
			local escadas = self.escadas.asNumber or 0;
			local becos = self.becos.asNumber or 0;
			local armadilhas = self.armadilhas.asNumber or 0;
			local passagens = self.passagens.asNumber or 0;

			-- Gera entradas [ENTRADA]
			for _ = 1, entradas, 1 do
				local side = math.floor(math.random() * 4);
				local x = 0;
				local y = 0;
				if side == 0 then
					x = 1;
				elseif side == 1 then
					x = horzSquare;
				elseif side == 2 then
					y = 1;
				elseif side == 3 then
					y = vertSquare;
				end;

				if x == 0 then
					x = math.random(2, (horzSquare-1));
				elseif y == 0 then
					y = math.random(2, (vertSquare-1));
				end;
				if map[x] and map[x][y] == "borda" then
					map[x][y] = "entrada";

					centros[centrosNum] = {x=x, y=y};
					centrosNum = centrosNum+1;
				end;
			end;

			--self.status.text = lang('scene.generator.status.message') .. lang('scene.generator.status.room');
			-- Gerar Salas [SALA]
			for _ = 1, salas, 1 do
				local width = math.random(tamMin, tamMax);
				local height = math.random(tamMin, tamMax);
				local posx = math.random(2, (horzSquare-1));
				local posy = math.random(2, (vertSquare-1));
				local midx = math.ceil(width/2);
				local midy = math.ceil(height/2);

				-- Verificar se a posição vai colidir com outra sala
				local valid = true;
				for x=1, width, 1 do
					for y=1, height, 1 do
						if posx+x <= horzSquare and posy+y <= vertSquare and map[posx+x][posy+y]~="nada" then
							valid = false;
						end;
					end;
				end; 

				-- Gere a SALA e suas PAREDES
				if valid then
					for x=1, width, 1 do
						for y=1, height, 1 do
							-- Adiciona o chao
							if posx+x <= horzSquare-1 and posy+y <= vertSquare-1 and map[posx+x][posy+y]=="nada" then
								map[posx+x][posy+y] = "chao";
							    if x==midx and y==midy then
							    	centros[centrosNum] = {x=posx+x, y=posy+y};
							    	centrosNum = centrosNum +1;
							    end;
							end;

							-- Se quina topo esquerdo adiciona parede. 
							if x==1 and y==1 then
								if posx+x-1 >= 1 and posy+y-1 >= 1 and map[posx+x-1][posy+y-1]=="nada" then
									map[posx+x-1][posy+y-1] = "parede";
								end;
							end;

							-- Se quina topo direito adiciona parede. 
							if x==width and y==1 then
								if posx+x+1 <= horzSquare and posy+y-1 >= 1 and map[posx+x+1][posy+y-1]=="nada" then
									map[posx+x+1][posy+y-1] = "parede";
								end;
							end;

							-- Se quina inferior esquerda adiciona parede. 
							if x==1 and y==height then
								if posx+x-1 >= 1 and posy+y-1 <= vertSquare and map[posx+x-1][posy+y+1]=="nada" then
									map[posx+x-1][posy+y+1] = "parede";
								end;
							end;

							-- Se quina inferior direita adiciona parede. 
							if x==width and y==height then
								if posx+x+1 <= horzSquare and posy+y+1 <= vertSquare and map[posx+x+1][posy+y+1]=="nada" then
									map[posx+x+1][posy+y+1] = "parede";
								end;
							end;

							-- Se topo adiciona parede
							if y==1 then
								if posx+x >= 1 and posx+x <= horzSquare and posy+y-1 >= 1 and map[posx+x][posy+y-1]=="nada" then
									map[posx+x][posy+y-1] = "parede";
								end;
							end;

							-- Se inferior adiciona parede
							if y==height then
								if posx+x >= 1 and posx+x <= horzSquare and posy+y+1 <= vertSquare and map[posx+x][posy+y+1]=="nada" then
									map[posx+x][posy+y+1] = "parede";
								end;
							end;

							-- Se esquerda adiciona parede
							if x==1 then
								if posx+x-1 >= 1 and posy+y >= 1 and posy+y <=vertSquare and map[posx+x-1][posy+y]=="nada" then
									map[posx+x-1][posy+y] = "parede";
								end;
							end;

							-- Se direita adiciona parede
							if x==width then
								if posx+x+1 <= horzSquare and posy+y >= 1 and posy+y <=vertSquare and map[posx+x+1][posy+y]=="nada" then
									map[posx+x+1][posy+y] = "parede";
								end;
							end;
						end;
					end;
				else 
					salas = salas + 1;
					if salas > limit then
						i = 2 * salas;
					end;
				end;
			end;

			-- Gera becos [BECOS]
			local corredores = {};
			local corredoresNum = 0;
			for i=1, becos, 1 do
				local x = math.random(2, (horzSquare-1));
				local y = math.random(2, (vertSquare-1));

				if map[x]~=nil and map[x][y] == "nada" then
					map[x][y] = "corredor";

					centros[centrosNum] = {x=x, y=y};
					centrosNum = centrosNum+1;

					corredoresNum = corredoresNum +1;
					corredores[corredoresNum] = {x=x, y=y};
				elseif becos <= (self.becos.asNumber or 0) then
					becos = becos +1;
				end;
			end;

			-- Gera corredores [CORREDOR]
			centrosNum = centrosNum -2;
			local secrets = {};
		    local secretsNum = 0;

			-- Mistura a ordem das salas
			if not self.natural.checked then
				local counter = centrosNum;
				while counter > 3 do
			        local index = math.random(2, counter);
			        centros[index], centros[counter] = centros[counter], centros[index];
			        counter = counter - 1;
			    end
			
				for i=1, centrosNum, 1 do
					local x1 = centros[i].x;
					local x2 = centros[i+1].x;
					local y1 = centros[i].y;
					local y2 = centros[i+1].y;

					local horz = x2 - x1;
					local dirx;
					
					if horz > 0 then
						dirx = 1;
					else 
						dirx = -1;
					end;
					
					horz = math.abs(horz);

					local vert = y2 - y1;
					local diry;
					
					if vert > 0 then
						diry = 1;
					else 
						diry = -1;
					end;
					
					vert = math.abs(vert);

					--showMessage(horz .. "|" .. vert);

					local y = y1; 
					local expand = 0;
					local aux = 0;
					for j=1, horz, 1 do
						local x = x1 + (dirx * (j+aux));
						if map[x][y] == "parede" then
							if map[x + dirx][y] == "parede" and map[x + dirx + dirx][y] == "parede" then
								y = y + diry;
								y1 = y1 + diry;
								vert = vert - diry;
								aux = aux-2;
								horz = horz + 2;
								expand = expand +2;
							else
								map[x][y] = "porta";
								corredoresNum = corredoresNum +1;
								corredores[corredoresNum] = {x=x, y=y};

								secretsNum = secretsNum +1;
								secrets[secretsNum] = {x=x, y=y};
							end;
						elseif map[x][y] == "nada" then
							map[x][y] = "corredor";

							corredoresNum = corredoresNum +1;
							corredores[corredoresNum] = {x=x, y=y};
						end;
					end;
					horz = horz - expand;

					local x = x1 + (dirx * horz);
					aux = 0;
					
					for j=1, vert, 1 do
						local yJ = y1 + (diry * (j+aux)); 
						if map[x][yJ] == "parede" then
							if map[x][yJ+diry] == "parede" and map[x][yJ+diry+diry] == "parede" then
								x = x + dirx;
								dirx = dirx * -1;
								aux = aux - 2;
								vert = vert + 2;
							else
								map[x][yJ] = "porta";
								corredoresNum = corredoresNum +1;
								corredores[corredoresNum] = {x=x, y=yJ};

								secretsNum = secretsNum +1;
								secrets[secretsNum] = {x=x, y=yJ};
							end;
						elseif map[x][y] == "nada" then
							map[x][y] = "corredor";

							corredoresNum = corredoresNum +1;
							corredores[corredoresNum] = {x=x, y=yJ};
						end;
					end;
				end;
			else
				-- Gera corredor de [CAVERNA]
				for i=1, centrosNum, 1 do
					local x1 = centros[i].x;
					local x2 = centros[i+1].x;
					local y1 = centros[i].y;
					local y2 = centros[i+1].y;

					local _, _, path = scene.grid:shortestPath(x1, y1, x2, y2);

					for j=1, #path, 1 do
						local x = path[j].i;
						local y = path[j].j;
						if map[x][y]=="parede" or map[x][y]=="nada" then
							map[x][y] = "corredor";

							corredoresNum = corredoresNum +1;
							corredores[corredoresNum] = {x=x, y=y};
						end;
					end;
				end;

			end;

			-- Gera paredes dos corredores [PAREDE]
			for i=1, corredoresNum, 1 do
				local cx = corredores[i].x;
				local cy = corredores[i].y;

				for x=-1, 1, 1 do
					for y=-1, 1, 1 do
						local px = cx+x;
						local py = cy+y;
						if map[px][py] == "nada" then
							map[px][py] = "parede";
						end;
					end;
				end;
			end;

			-- Gera escadas [ESCADA]
			for i=1, escadas, 1 do
				local pos = math.random(centrosNum);
				local x = centros[pos].x;
				local y = centros[pos].y;
				if map[x][y] == "corredor" then
					map[x][y] = "escada";
				elseif map[x][y] == "chao" then
					map[x][y] = "escada";
				end;
			end;

			-- Marcando passagens secretas [PASSAGEM]
			if secretsNum>0 then
				for i=1, passagens, 1 do
					local pos = math.random(secretsNum);
					local x = secrets[pos].x;
					local y = secrets[pos].y;

					if map[x][y] == "porta"then
						map[x][y] = "parede";
					end;
				end;
			end;

			-- Filtro de Caverna
			if self.natural.checked then
				for x=1, horzSquare, 1 do
					for y=1, vertSquare, 1 do
						local tl, t, tr, l, r, bl, b, br;
						if map[x-1]~= nil then
							tl =  map[x-1][y-1];
							l =  map[x-1][y];
							bl =  map[x-1][y+1];
						end;
						if map[x+1]~= nil then
							tr =  map[x+1][y-1];
							r =  map[x+1][y];
							br =  map[x+1][y+1];
						end;
						t = map[x][y-1];
						b = map[x][y+1];

						local piso = 0;
						local paredes = 0;

						if tl == "chao" then
							piso = piso + 1;
						elseif tl == "parede" or tl == "borda" then
							paredes = paredes + 1;
						end;
						if t == "chao" then
							piso = piso + 1;
						elseif t == "parede" or t == "borda" then
							paredes = paredes + 1;
						end;
						if tr == "chao" then
							piso = piso + 1;
						elseif tr == "parede" or tr == "borda" then
							paredes = paredes + 1;
						end;
						if l == "chao" then
							piso = piso + 1;
						elseif l == "parede" or l == "borda" then
							paredes = paredes + 1;
						end;
						if r == "chao" then
							piso = piso + 1;
						elseif r == "parede" or r == "borda" then
							paredes = paredes + 1;
						end;
						if  bl == "chao" then
							piso = piso + 1;
						elseif bl == "parede" or bl == "borda" then
							paredes = paredes + 1;
						end;
						if b == "chao" then
							piso = piso + 1;
						elseif b == "parede" or b == "borda" then
							paredes = paredes + 1;
						end;
						if br == "chao" then
							piso = piso + 1;
						elseif br == "parede" or br == "borda" then
							paredes = paredes + 1;
						end;
						if piso>= 5 then
							map[x][y] = "chao";
						elseif paredes >= 5 and map[x][y]=="chao" then
							map[x][y] = "parede";
						end;
					end;
				end;
			end;

			-- Posicionar os [TILES]
			local endTest = true;
			if endTest then
				for x=1, horzSquare, 1 do
					--self.status.text = lang('scene.generator.status.message') .. lang('scene.generator.status.tiles') .. x;
					for y=1, vertSquare, 1 do
						if map[x][y] ~= "nada" then
							local token = scene.items:addToken("background");
							token.x = (x-1) * size;
							token.y = (y-1) * size;

							token.width = token.width * thick;
							token.height = token.height * thick;

							-- Descobre o que tem envolta do token que está sendo analisado
							local tl, t, tr, l, r, bl, b, br;
							if map[x-1]~= nil then
								tl =  map[x-1][y-1];
								l =  map[x-1][y];
								bl =  map[x-1][y+1];
							end;
							if map[x+1]~= nil then
								tr =  map[x+1][y-1];
								r =  map[x+1][y];
								br =  map[x+1][y+1];
							end;
							t = map[x][y-1];
							b = map[x][y+1];

							-- Define o tipo de tile e sua rotação
							if map[x][y] == "chao" or map[x][y] == "corredor" then
								if (t=="parede" or t=="borda") and (r=="parede" or r=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.floor_deadend.url;
									token.image.rotation = 180;
								elseif (t=="parede" or t=="borda") and (l=="parede" or l=="borda") and (r=="parede" or r=="borda") then
									token.image.url = self.floor_deadend.url;
									token.image.rotation = 270;
								elseif (t=="parede" or t=="borda") and (l=="parede" or l=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.floor_deadend.url;
									token.image.rotation = 0;
								elseif (r=="parede" or r=="borda") and (l=="parede" or l=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.floor_deadend.url;
									token.image.rotation = 90;
								elseif (r=="parede" or r=="borda") and (l=="parede" or l=="borda") then
									token.image.url = self.floor_line.url;
									token.image.rotation = 90;
								elseif (t=="parede" or t=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.floor_line.url;
								elseif (t=="parede" or t=="borda") and (l=="parede" or l=="borda") then
									if (br=="parede" or br=="borda") then
										token.image.url = self.floor_curve.url;
									else 
										token.image.url = self.floor_tip.url;
									end;
								elseif (b=="parede" or b=="borda") and (l=="parede" or l=="borda") then
									if (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_curve.url;
									else 
										token.image.url = self.floor_tip.url;
									end;
									token.image.rotation = 90;
								elseif (t=="parede" or t=="borda") and (r=="parede" or r=="borda") then
									if (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_curve.url;
									else 
										token.image.url = self.floor_tip.url;
									end;
									token.image.rotation = 270;
								elseif (b=="parede" or b=="borda") and (r=="parede" or r=="borda") then
									if (tl=="parede" or tl=="borda") then
										token.image.url = self.floor_curve.url;
									else 
										token.image.url = self.floor_tip.url;
									end;
									token.image.rotation = 180;
								elseif (t=="parede" or t=="borda") then
									if (br=="parede" or br=="borda") and (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_t.url;
									elseif (br=="parede" or br=="borda") then
										token.image.url = self.floor_coneright.url;
									elseif (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_coneleft.url;
									else 
										token.image.url = self.floor_side.url;
									end;
								elseif (l=="parede" or l=="borda") then
									if (tr=="parede" or tr=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_t.url;
									elseif (br=="parede" or br=="borda") then
										token.image.url = self.floor_coneleft.url;
									elseif (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_coneright.url;
									else 
										token.image.url = self.floor_side.url;
									end;
									token.image.rotation = 90;
								elseif (b=="parede" or b=="borda") then
									if (tr=="parede" or tr=="borda") and (tl=="parede" or tl=="borda") then
										token.image.url = self.floor_t.url;
									elseif (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_coneleft.url;
									elseif (tl=="parede" or tl=="borda") then
										token.image.url = self.floor_coneright.url;
									else 
										token.image.url = self.floor_side.url;
									end;
									token.image.rotation = 180;
								elseif (r=="parede" or r=="borda") then
									if (bl=="parede" or bl=="borda") and (tl=="parede" or tl=="borda") then
										token.image.url = self.floor_t.url;
									elseif (tl=="parede" or tl=="borda") then
										token.image.url = self.floor_coneleft.url;
									elseif (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_coneright.url;
									else 
										token.image.url = self.floor_side.url;
									end;
									token.image.rotation = 270;
								else 
									if (tl=="parede" or tl=="borda") and (tr=="parede" or tr=="borda") and (bl=="parede" or bl=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_cross.url;
									elseif (tl=="parede" or tl=="borda") and (tr=="parede" or tr=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_twoway.url;
										token.image.rotation = 90;
									elseif (bl=="parede" or bl=="borda") and (tr=="parede" or tr=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_twoway.url;
										token.image.rotation = 180;
									elseif (bl=="parede" or bl=="borda") and (tl=="parede" or tl=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_twoway.url;
										token.image.rotation = 270;
									elseif (bl=="parede" or bl=="borda") and (tl=="parede" or tl=="borda") and (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_twoway.url;
										token.image.rotation = 0;
									elseif (bl=="parede" or bl=="borda") and (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_opositeway.url;
									elseif (tl=="parede" or tl=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_opositeway.url;
										token.image.rotation = 90;
									elseif (tl=="parede" or tl=="borda") and (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_exit.url;
									elseif (tl=="parede" or tl=="borda") and (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_exit.url;
										token.image.rotation = 90;
									elseif (br=="parede" or br=="borda") and (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_exit.url;
										token.image.rotation = 180;
									elseif (tr=="parede" or tr=="borda") and (br=="parede" or br=="borda") then
										token.image.url = self.floor_exit.url;
										token.image.rotation = 270;
									elseif (br=="parede" or br=="borda") then
										token.image.url = self.floor_opencurve.url;
									elseif (tr=="parede" or tr=="borda") then
										token.image.url = self.floor_opencurve.url;
										token.image.rotation = 90;
									elseif (tl=="parede" or tl=="borda") then
										token.image.url = self.floor_opencurve.url;
										token.image.rotation = 180;
									elseif (bl=="parede" or bl=="borda") then
										token.image.url = self.floor_opencurve.url;
										token.image.rotation = 270;
									else
										token.image.url = self.floor_inside.url;
									end;
								end;								
							elseif map[x][y] == "parede" then
								if (b=="parede" or b=="borda") and (t=="parede" or t=="borda") and (l=="parede" or l=="borda") and (r=="parede" or r=="borda") then
									token.image.url = self.wall_cross.url;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (b=="parede" or b=="borda") and (l=="parede" or l=="borda") and (r=="parede" or r=="borda") then
									token.image.url = self.wall_t.url;
									local aux = {};
									aux[1] = {x=x*size, y=(y-0.6)*size};
									aux[2] = {x=x*size, y=(y-0.4)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[4] = {x=(x-0.4)*size, y=y*size};
									aux[5] = {x=(x-0.6)*size, y=y*size};
									aux[6] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[8] = {x=(x-1)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (b=="parede" or b=="borda") and (t=="parede" or t=="borda") and (r=="parede" or r=="borda") then
									token.image.url = self.wall_t.url;
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (l=="parede" or l=="borda") and (t=="parede" or t=="borda") and (r=="parede" or r=="borda") then
									token.image.url = self.wall_t.url;
									token.image.rotation = 180;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[8] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (l=="parede" or l=="borda") and (t=="parede" or t=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.wall_t.url;
									token.image.rotation = 270;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=y*size};
									aux[4] = {x=(x-0.6)*size, y=y*size};
									aux[5] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[6] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[8] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (l=="parede" or l=="borda") and (r=="parede" or r=="borda") then
									token.image.url = self.wall_line.url;
									local aux = {};
									aux[1] = {x=x*size, y=(y-0.6)*size};
									aux[2] = {x=x*size, y=(y-0.4)*size};
									aux[3] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[4] = {x=(x-1)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (t=="parede" or t=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.wall_line.url;
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y)*size};
									aux[4] = {x=(x-0.6)*size, y=(y)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (r=="parede" or r=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.wall_curve.url;
									local aux = {};
									aux[1] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[2] = {x=x*size, y=(y-0.6)*size};
									aux[3] = {x=x*size, y=(y-0.4)*size};
									aux[4] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[5] = {x=(x-0.4)*size, y=y*size};
									aux[6] = {x=(x-0.6)*size, y=y*size};
									aux[7] = {x=(x-0.6)*size, y=(y-0.4)*size};
									if not self.natural. checked then
										aux[8] = {x=(x-1)*size, y=(y-0.4)*size};
										aux[9] = {x=(x-1)*size, y=(y-0.6)*size};
										aux[10] = {x=(x-0.6)*size, y=(y-0.6)*size};
										aux[11] = {x=(x-0.6)*size, y=(y-1)*size};
										aux[12] = {x=(x-0.4)*size, y=(y-1)*size};
									end;
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (r=="parede" or r=="borda") and (t=="parede" or t=="borda") then
									token.image.url = self.wall_curve.url;
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-0.6)*size};
									aux[2] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[4] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.6)*size};
									aux[6] = {x=x*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=(y-0.4)*size};
									if not self.natural. checked then
										aux[8] = {x=(x-0.4)*size, y=y*size};
										aux[9] = {x=(x-0.6)*size, y=y*size};
										aux[10] = {x=(x-0.6)*size, y=(y-0.4)*size};
										aux[11] = {x=(x-1)*size, y=(y-0.4)*size};
										aux[12] = {x=(x-1)*size, y=(y-0.6)*size};
									end;
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (l=="parede" or l=="borda") and (t=="parede" or t=="borda") then
									token.image.url = self.wall_curve.url;
									token.image.rotation = 180;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[2] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[3] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[4] = {x=(x-0.6)*size, y=(y-0.6)*size};
									aux[5] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[7] = {x=(x-0.4)*size, y=(y-0.6)*size};
									if not self.natural. checked then
										aux[8] = {x=x*size, y=(y-0.6)*size};
										aux[9] = {x=x*size, y=(y-0.4)*size};
										aux[10] = {x=(x-0.4)*size, y=(y-0.4)*size};
										aux[11] = {x=(x-0.4)*size, y=y*size};
										aux[12] = {x=(x-0.6)*size, y=y*size};
									end;
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (l=="parede" or l=="borda") and (b=="parede" or b=="borda") then
									token.image.url = self.wall_curve.url;
									token.image.rotation = 270;
									local aux = {};

									aux[1] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[2] = {x=(x-0.4)*size, y=y*size};
									aux[3] = {x=(x-0.6)*size, y=y*size};
									aux[4] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[5] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[6] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[7] = {x=(x-0.6)*size, y=(y-0.6)*size};
									if not self.natural. checked then
										aux[8] = {x=(x-0.6)*size, y=(y-1)*size};
										aux[9] = {x=(x-0.4)*size, y=(y-1)*size};
										aux[10] = {x=(x-0.4)*size, y=(y-0.6)*size};
										aux[11] = {x=x*size, y=(y-0.6)*size};
										aux[12] = {x=x*size, y=(y-0.4)*size};
									end;
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (l=="parede" or l=="borda") then
									token.image.url = self.wall_deadend.url;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (b=="parede" or b=="borda") then
									token.image.url = self.wall_deadend.url;
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (r=="parede" or r=="borda") then
									token.image.url = self.wall_deadend.url;
									token.image.rotation = 180;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif (t=="parede" or t=="borda") then
									token.image.url = self.wall_deadend.url;
									token.image.rotation = 270;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								else
									token.image.url = self.wall_pilar.url;
									local aux = {};
									aux[1] = {x=(x-0.2)*size, y=(y-0.8)*size};
									aux[2] = {x=(x-0.2)*size, y=(y-0.2)*size};
									aux[3] = {x=(x-0.8)*size, y=(y-0.2)*size};
									aux[4] = {x=(x-0.8)*size, y=(y-0.8)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								end;
							elseif map[x][y] == "borda" then
								if b == "borda" and t == "borda" and (l=="parede" or r=="parede") then
									token.image.url = self.wall_t.url;
									if l=="parede" then
										token.image.rotation = 270;
										local aux = {};
										aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
										aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
										aux[3] = {x=(x-0.4)*size, y=y*size};
										aux[4] = {x=(x-0.6)*size, y=y*size};
										aux[5] = {x=(x-0.6)*size, y=(y-0.4)*size};
										aux[6] = {x=(x-1)*size, y=(y-0.4)*size};
										aux[7] = {x=(x-1)*size, y=(y-0.6)*size};
										aux[8] = {x=(x-0.6)*size, y=(y-0.6)*size};
										scene.fogOfWar:addOpaqueArea(aux);
									else
										token.image.rotation = 90;
										local aux = {};
										aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
										aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
										aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
										aux[4] = {x=x*size, y=(y-0.6)*size};
										aux[5] = {x=x*size, y=(y-0.4)*size};
										aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
										aux[7] = {x=(x-0.4)*size, y=y*size};
										aux[8] = {x=(x-0.6)*size, y=y*size}
										scene.fogOfWar:addOpaqueArea(aux);
									end;
								elseif r == "borda" and l == "borda" and (b=="parede" or t=="parede") then
									token.image.url = self.wall_t.url;
									if t=="parede" then
										token.image.rotation = 180;
										local aux = {};
										aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
										aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
										aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
										aux[4] = {x=x*size, y=(y-0.6)*size};
										aux[5] = {x=x*size, y=(y-0.4)*size};
										aux[6] = {x=(x-1)*size, y=(y-0.4)*size};
										aux[7] = {x=(x-1)*size, y=(y-0.6)*size};
										aux[8] = {x=(x-0.6)*size, y=(y-0.6)*size};
										scene.fogOfWar:addOpaqueArea(aux);
									else
										local aux = {};
										aux[1] = {x=x*size, y=(y-0.6)*size};
										aux[2] = {x=x*size, y=(y-0.4)*size};
										aux[3] = {x=(x-0.4)*size, y=(y-0.4)*size};
										aux[4] = {x=(x-0.4)*size, y=y*size};
										aux[5] = {x=(x-0.6)*size, y=y*size};
										aux[6] = {x=(x-0.6)*size, y=(y-0.4)*size};
										aux[7] = {x=(x-1)*size, y=(y-0.4)*size};
										aux[8] = {x=(x-1)*size, y=(y-0.6)*size};
										scene.fogOfWar:addOpaqueArea(aux);
									end;
								elseif b == "borda" and t == "borda" then
									token.image.url = self.wall_line.url;
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y)*size};
									aux[4] = {x=(x-0.6)*size, y=(y)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif r == "borda" and l == "borda" then
									token.image.url = self.wall_line.url;
									local aux = {};
									aux[1] = {x=x*size, y=(y-0.6)*size};
									aux[2] = {x=x*size, y=(y-0.4)*size};
									aux[3] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[4] = {x=(x-1)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif r == "entrada" then
									token.image.url = self.wall_deadend.url;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif l == "entrada" then
									token.image.url = self.wall_deadend.url;
									token.image.rotation = 180;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif b == "entrada" then
									token.image.url = self.wall_deadend.url;
									token.image.rotation = 270;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								elseif t == "entrada" then
									token.image.url = self.wall_deadend.url;
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								else
									token.image.url = self.wall_curve.url;
									if b~=nil and l~=nil then
										token.image.rotation = 270;
									elseif t~=nil and l~=nil then
										token.image.rotation = 180;
									elseif t~=nil and r~=nil then
										token.image.rotation = 90;
									end;
									local aux = {};
									aux[1] = {x=(x-0.6)*size, y=(y-1)*size};
									aux[2] = {x=(x-0.4)*size, y=(y-1)*size};
									aux[3] = {x=(x-0.4)*size, y=(y-0.6)*size};
									aux[4] = {x=x*size, y=(y-0.6)*size};
									aux[5] = {x=x*size, y=(y-0.4)*size};
									aux[6] = {x=(x-0.4)*size, y=(y-0.4)*size};
									aux[7] = {x=(x-0.4)*size, y=y*size};
									aux[8] = {x=(x-0.6)*size, y=y*size};
									aux[9] = {x=(x-0.6)*size, y=(y-0.4)*size};
									aux[10] = {x=(x-1)*size, y=(y-0.4)*size};
									aux[11] = {x=(x-1)*size, y=(y-0.6)*size};
									aux[12] = {x=(x-0.6)*size, y=(y-0.6)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								end;
							elseif map[x][y] == "porta" then
								token.image.url = self.door_light.url;
								if (b == "parede" or b =="porta") and (t == "parede" or t=="porta") then
									token.image.rotation = 90;
									local aux = {};
									aux[1] = {x=(x-0.525)*size, y=(y-1.5)*size};
									aux[2] = {x=(x-0.475)*size, y=(y-1.5)*size};
									aux[3] = {x=(x-0.475)*size, y=(y+0.5)*size};
									aux[4] = {x=(x-0.525)*size, y=(y+0.5)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								else
									local aux = {};
									aux[1] = {x=(x+0.5)*size, y=(y-0.525)*size};
									aux[2] = {x=(x+0.5)*size, y=(y-0.475)*size};
									aux[3] = {x=(x-1.5)*size, y=(y-0.475)*size};
									aux[4] = {x=(x-1.5)*size, y=(y-0.525)*size};
									scene.fogOfWar:addOpaqueArea(aux);
								end;
							elseif map[x][y] == "escada" then
								token.image.url = self.floor_stair.url;
							elseif map[x][y] == "entrada" then
								token.image.url = self.door_heavy.url;
								if b== "borda" and t == "borda" then
									token.image.rotation = 90;
								end;
							end;
						end;
					end;
				end;
			end;

			-- Posicionando tiles de armadilhas [ARMADILHA]
			for i=1, armadilhas, 1 do
				local pos = math.random(centrosNum);
				local x = centros[pos].x;
				local y = centros[pos].y;
				if map[x][y] == "corredor" or map[x][y] == "chao" or map[x][y] == "escada" then
					local token = scene.items:addToken("background");
					token.x = (x-1) * size;
					token.y = (y-1) * size;

					token.width = token.width * thick;
					token.height = token.height * thick;
					token.image.url = self.trap.url;
					token.visible = false;
				end;
			end;

			-- Posicionando tiles de passagens secretas [PASSAGEM]
			for i=1, secretsNum, 1 do
				local x = secrets[i].x;
				local y = secrets[i].y;
				if map[x][y] == "parede"then
					local t, b;
					
					t = map[x][y-1];
					b = map[x][y+1];

					local token = scene.items:addToken("background");
					token.x = (x-1) * size;
					token.y = (y-1) * size;

					token.width = token.width * thick;
					token.height = token.height * thick;
					token.image.url = self.passage.url;
					token.visible = false;

					if (b == "parede" or b =="porta") and (t == "parede" or t=="porta") then
						token.image.rotation = 90;
					end;

				end;
			end;

			node.salas = self.salas.text;
			node.tamMax = self.tamMax.text;
			node.tamMin = self.tamMin.text;
			node.entradas = self.entradas.text;
			node.escadas = self.escadas.text;
			node.becos = self.becos.text;
			node.armadilhas = self.armadilhas.text;
			node.passagens = self.passagens.text;
			node.natural = self.natural.checked;
			node.thick = self.thick.value;
			node.style = self.styleOptions.value;
			node.save = {};
			node.save[1] = self.door_light.url;
			node.save[2] = self.door_heavy.url;
			node.save[3] = self.floor_deadend.url;
			node.save[4] = self.floor_line.url;
			node.save[5] = self.floor_curve.url;
			node.save[6] = self.floor_tip.url;
			node.save[7] = self.floor_t.url;
			node.save[8] = self.floor_coneright.url;
			node.save[9] = self.floor_coneleft.url;
			node.save[10] = self.floor_side.url;
			node.save[11] = self.floor_cross.url;
			node.save[12] = self.floor_twoway.url;
			node.save[13] = self.floor_opositeway.url;
			node.save[14] = self.floor_exit.url;
			node.save[15] = self.floor_opencurve.url;
			node.save[16] = self.floor_inside.url;
			node.save[17] = self.floor_stair.url;
			node.save[18] = self.wall_cross.url;
			node.save[19] = self.wall_t.url;
			node.save[20] = self.wall_line.url;
			node.save[21] = self.wall_curve.url;
			node.save[22] = self.wall_deadend.url;
			node.save[23] = self.wall_pilar.url;
			node.save[24] = self.trap.url;
			node.save[25] = self.passage.url;

			self:close();
		end;
		
		function self:processarCancel()
			node.salas = self.salas.text;
			node.tamMax = self.tamMax.text;
			node.tamMin = self.tamMin.text;
			node.entradas = self.entradas.text;
			node.escadas = self.escadas.text;
			node.becos = self.becos.text;
			node.thick = self.thick.value;
			node.style = self.styleOptions.value;
			node.armadilhas = self.armadilhas.text;
			node.passagens = self.passagens.text;
			node.natural = self.natural.checked;
			node.save = {};
			node.save[1] = self.door_light.url;
			node.save[2] = self.door_heavy.url;
			node.save[3] = self.floor_deadend.url;
			node.save[4] = self.floor_line.url;
			node.save[5] = self.floor_curve.url;
			node.save[6] = self.floor_tip.url;
			node.save[7] = self.floor_t.url;
			node.save[8] = self.floor_coneright.url;
			node.save[9] = self.floor_coneleft.url;
			node.save[10] = self.floor_side.url;
			node.save[11] = self.floor_cross.url;
			node.save[12] = self.floor_twoway.url;
			node.save[13] = self.floor_opositeway.url;
			node.save[14] = self.floor_exit.url;
			node.save[15] = self.floor_opencurve.url;
			node.save[16] = self.floor_inside.url;
			node.save[17] = self.floor_stair.url;
			node.save[18] = self.wall_cross.url;
			node.save[19] = self.wall_t.url;
			node.save[20] = self.wall_line.url;
			node.save[21] = self.wall_curve.url;
			node.save[22] = self.wall_deadend.url;
			node.save[23] = self.wall_pilar.url;
			node.save[24] = self.trap.url;
			node.save[25] = self.passage.url;

			self:close();
		end;
		]]>
	</script>
	
	<event name="onKeyUp">	
		if (event.keyCode == 0x89) or (event.keyCode == 0x1B) then
			setTimeout(
				function()
					self:processarCancel();
				end, 1);
			
			event.keyCode = 0;
			event.key = "";
		end;
	</event>	
	
	<event name="onCancelRequest">
		self:processarCancel();
	</event>
	
</popupForm>